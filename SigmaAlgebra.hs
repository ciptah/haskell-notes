-- Sigma-algebra, an important building block for probability space and measure.

module SigmaAlgebra (
  SigmaAlgebra,
  measurable,
  forAllSets, thereExistsSet,
  isValid,
  sigmaAlgebra,
  canMeasure,
  sampleSpace,
  generate
) where

import Sets
import Sequences
import Data.Maybe (fromJust, fromMaybe)

-- A few examples of sigma algebra on outcomes a.
--   BorelReals = The SA generated by the open sets of R.
--   Otherwise imagine having a sigma-algebra defined by the set of subsets.
data SigmaAlgebra a = SigmaAlgebra (Collection (Set a)) deriving (Eq)

-- All the sets within the sigma algebra F.
-- Technically a sigma-algebra is a collection.
-- However some differences, like the union operator doesn't guarantee to give
-- out a sigma-algebra.
measurable :: SigmaAlgebra a -> Collection (Set a)
measurable (SigmaAlgebra x) = x

-- Shortcuts for statements about all measurable set in the SA.
forAllSets sa = forAll (measurable sa)
thereExistsSet sa = thereExists (measurable sa)

-- Is the given event a measurable set wrt this SA?
sa `canMeasure` event = event ∈ measurable sa

-- See Definition 2.2 of DS-GA 1002 notes probability_basics.pdf
isValid :: (Eq w) => Set w -> SigmaAlgebra w -> Bool
isValid o f = 
    -- sampleSpace candidate == o should already be implied by the below
    f `canMeasure` o
    && (forAllSets f $ \s -> s ⊆ o && f `canMeasure` (o `minus` s))
    && (forAll (countableUnions $ measurable f) $ \u -> f `canMeasure` u)

-- Constructor that checks the set of sets against w
sigmaAlgebra :: (Eq w) => Set w -> Set (Set w) -> Maybe (SigmaAlgebra w)
sigmaAlgebra o s
  | isValid o candidate = Just candidate -- valid
  | otherwise = Nothing -- invalid
  where candidate = SigmaAlgebra s

-- Because of the definition of a Sigma-Algebra, the original set Omega is
-- included as the maximal set contained in F. That means it is the singleton
-- member of Set-a's that is both included in the S.A. and covers all of S.A.
sampleSpace :: SigmaAlgebra a -> Set a
sampleSpace sa = fromJust $ singleton $ Everything % \event ->
  sa `canMeasure` event && (forAllSets sa $ \other -> other ⊆ event)

----------- Generating sigma-algebra from arbitrary subsets.

-- First define the machinery required.
-- "countable number of complement, union, and intersection operators"
-- First, define the atomic operations.
ops :: (Eq w) => Set w -> [Set w] -> [Set w -> Set w]
ops all [] = []
ops all (set:remainder) = comp : union : intersect : ops all remainder
  where comp = minus all
        union = (∪) set
        intersect = (∩) set

-- "grow" the operations using composition.
-- https://stackoverflow.com/questions/9542313/how-to-generate-a-list-of-all-possible-strings-from-shortest-to-longest
-- For example: intersect A $ union B $ complement $ intersect C $ id $ ...
grow :: [Set w -> Set w] -> [Set w -> Set w]
grow ops = [op . rest | op <- ops, rest <- id:(grow ops)]

-- Let F be an arbitrary family of subsets of X. Then there exists a unique
-- smallest σ-algebra which contains every set in F
-- This σ-algebra is denoted σ(F) and is called the σ-algebra generated by F.
-- First arg is X. Second arg is the predicates that form the subsets of X.
generate :: (Eq w) => Set w -> [w -> Bool] -> SigmaAlgebra w
generate samples predicates = fromJust $ sigmaAlgebra samples events
  where events | subsets == [] = singletonOf empty ∪ singletonOf samples
               -- This means: take the subsets, generate the compositions,
               -- evaluate against the empty set to get the actual sets
               -- and turn everything into a collection by applying
               -- singletonOf and unionAll.
               | otherwise = unionAll $ map singletonOf $ opResults
        subsets = map ((%) samples) predicates -- :: [Set w]
        opResults = map ($ empty) $ grow $ ops samples $ subsets -- :: [Set w]

--------------- The Borel σ-algebra of Real numbers --------

openInterval :: Maybe RealNum -> Maybe RealNum -> Set RealNum
openInterval Nothing Nothing = reals
openInterval min max = reals % \r ->
  (fromMaybe True $ pure (<) <*> min <*> pure r) &&
  (fromMaybe True $ pure (<) <*> pure r <*> max)

openSetsInR = (Everything :: Set (Set RealNum)) % \u ->
  forAll u $ \x -> thereExists positiveReals $ \δ ->
    let nbrhd = pure (x - δ) `openInterval` pure (x - δ) in
    nbrhd /= u && nbrhd ⊆ u

