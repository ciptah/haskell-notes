-- Sigma-algebra, an important building block for probability space and measure.

module SigmaAlgebra (
  SigmaAlgebra,
  measurable,
  forAllSets, thereExistsSet,
  isValid,
  sigmaAlgebra,
  canMeasure,
  sampleSpace,
  generate
) where

import Sets
import Sequences
import Data.Maybe (fromJust, fromMaybe)

-- A few examples of sigma algebra on outcomes a.
--   BorelReals = The SA generated by the open sets of R.
--   Otherwise imagine having a sigma-algebra defined by the set of subsets.
data SigmaAlgebra a = SigmaAlgebra (Collection (Set a)) deriving (Eq)

-- All the sets within the sigma algebra F.
-- Technically a sigma-algebra is a collection.
-- However some differences, like the union operator doesn't guarantee to give
-- out a sigma-algebra.
measurable :: SigmaAlgebra a -> Collection (Set a)
measurable (SigmaAlgebra x) = x

-- Shortcuts for statements about all measurable set in the SA.
forAllSets sa = forAll (measurable sa)
thereExistsSet sa = thereExists (measurable sa)

-- Is the given event a measurable set wrt this SA?
sa `canMeasure` event = event ∈ measurable sa

-- See Definition 2.2 of DS-GA 1002 notes probability_basics.pdf
isValid :: (Eq w) => Set w -> SigmaAlgebra w -> Bool
isValid o f = 
    -- sampleSpace candidate == o should already be implied by the below
    f `canMeasure` o
    && (forAllSets f $ \s -> s ⊆ o && f `canMeasure` (o `minus` s))
    && (forAll (countableUnions $ measurable f) $ \u -> f `canMeasure` u)

-- Constructor that checks the set of sets against w
sigmaAlgebra :: (Eq w) => Set w -> Set (Set w) -> Maybe (SigmaAlgebra w)
sigmaAlgebra o s
  | isValid o candidate = Just candidate -- valid
  | otherwise = Nothing -- invalid
  where candidate = SigmaAlgebra s

-- Because of the definition of a Sigma-Algebra, the original set Omega is
-- included as the maximal set contained in F. That means it is the singleton
-- member of Set-a's that is both included in the S.A. and covers all of S.A.
sampleSpace :: SigmaAlgebra a -> Set a
sampleSpace sa = fromJust $ singleton $ Everything % \event ->
  sa `canMeasure` event && (forAllSets sa $ \other -> other ⊆ event)

----------- Generating sigma-algebra from arbitrary subsets.

data Op w = Union (Set w) | Intersect (Set w) | Complement

-- First define the machinery required.
-- "countable number of complement, union, and intersection operators"
-- First, define the atomic operations.
-- Get all sequences of operations that can be made.
ops2 :: (Eq w) => Set w -> Collection (Set w) -> Collection ([Op w])
ops2 all subsets | subsets == empty = empty
                 | otherwise = Everything % \ops -> (and $ map ok ops)
  -- Each op is based on a set inside the subsets
  where ok (Union x) = x ⊆ all && x ∈ subsets
        ok (Intersect x) = x ⊆ all && x ∈ subsets
        ok Complement = True

-- "grow" the operations using composition.
-- https://stackoverflow.com/questions/9542313/how-to-generate-a-list-of-all-possible-strings-from-shortest-to-longest
-- For example: intersect A $ union B $ complement $ intersect C $ id $ ...
-- Get all subsets that can be created by applying the operations.
grow2 :: (Eq w) => Set w -> Collection (Set w) -> Collection (Set w)
grow2 all seed = Everything % \s -> thereExists (ops2 all seed) $ \ops ->
  apply all ops == s
  where apply all [] = empty
        apply all (Complement:remainder) = all `minus` (apply all remainder)
        apply all ((Union x):remainder) = x ∪ (apply all remainder)
        apply all ((Intersect x):remainder) = x ∩ (apply all remainder)

-- Let F be an arbitrary family of subsets of X. Then there exists a unique
-- smallest σ-algebra which contains every set in F
-- This σ-algebra is denoted σ(F) and is called the σ-algebra generated by F.
-- First arg is X. Second arg is the predicates that form the subsets of X.
generate :: (Eq w) => Set w -> (Set w -> Bool) -> SigmaAlgebra w
generate samples selector = fromJust $ sigmaAlgebra samples events
  where events | subsets == empty = singletonOf empty ∪ singletonOf samples
               -- This means: take the subsets, generate the compositions,
               -- evaluate against the empty set to get the actual sets
               -- and turn everything into a collection by applying
               -- singletonOf and unionAll.
               | otherwise = grow2 samples subsets
        subsets = Everything % \sub -> sub ⊆ samples && selector sub

--------------- The Borel σ-algebra of Real numbers --------

openInterval :: Maybe RealNum -> Maybe RealNum -> Set RealNum
openInterval Nothing Nothing = reals
openInterval min max = reals % \r ->
  (fromMaybe True $ pure (<) <*> min <*> pure r) &&
  (fromMaybe True $ pure (<) <*> pure r <*> max)

isOpenSet :: Set RealNum -> Bool
isOpenSet u = forAll u $ \x -> thereExists positiveReals $ \δ ->
    let nbrhd = pure (x - δ) `openInterval` pure (x - δ) in
    nbrhd /= u && nbrhd ⊆ u

borelReals = generate reals isOpenSet
