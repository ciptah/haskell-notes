-- Function spaces and operations on functions.
-- Reference:
-- https://www.math.ucdavis.edu/~hunter/measure_theory/measure_notes_ch7.pdf

{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE Rank2Types #-}

module FunctionSpaces
  ( pow
  , root
  , lpNorm
  , lp2Norm
  , lpSpace
  , lp2Space
  , fnAdd
  , fnSub
  , fnMul
  , LpFnSequence
  , lpFnSequence
  )
where

import           GHC.TypeLits
import           Data.Proxy

import           Sets
import           Functions
import           Sequences
import           Vectors
import           SigmaAlgebra
import           Measures
import           Integral

pow :: RealNum -> R1 -> R1
pow p x = Vec [(x @@ 0) ** p]

root :: RealNum -> Maybe ExtR1 -> Maybe ExtR1
root p (Just v) = root__ $ vecToList v
 where
  root__ [PosInf  ] = Just $ Vec [PosInf]
  root__ [Finite x] = Just $ Vec [Finite $ x ** (1 / p)]
  root__ _          = Nothing
root p _ = Nothing

-- The literature mentions "measurable functions" but doesn't define what
-- the sigma-algebra of the codomain is. I'll just take it as the Lebesgue
-- sigma-algebra on R.

-- Lp-space is defined on the measure space of the domain Lp(X, A, µ) 
-- and the exponent-value p. We don't actually need a type.

-- Only for p >= 1. Infinity norm is special that will come later.
lpNorm_
  :: Defined dom a
  => RealNum
  -> Measure dom a
  -> Fn dom a AllOf R1
  -> Maybe ExtR1
lpNorm_ p measure fn = if p >= 1 then root_ else Nothing
 where
  all   = (outcomes $ algebra $ measure) % \w -> True
  pfn   = pow p <<. abs <<. fn
  root_ = root p $ integral measure pfn all

lpNorm
  :: Defined dom a => ExtR -> Measure dom a -> Fn dom a AllOf R1 -> Maybe ExtR1
lpNorm (Finite x) measure fn = lpNorm_ x measure fn

lpSpace :: Defined dom a => ExtR -> Measure dom a -> Subset (Fn dom a AllOf R1)
lpSpace (Finite p) measure =
  everything % \fn -> justFinite $ lpNorm_ p measure fn

lp2Norm :: Defined dom a => Measure dom a -> Fn dom a AllOf R1 -> Maybe ExtR1
lp2Norm = lpNorm 2

lp2Space :: Defined dom a => Measure dom a -> Subset (Fn dom a AllOf R1)
lp2Space = lpSpace (Finite 2)

-------------- Operations of functions as infinite dimensional vectors ------------------

fnAdd
  :: Defined dom a
  => Fn dom a AllOf R1
  -> Fn dom a AllOf R1
  -> Fn dom a AllOf R1
fnAdd f1 f2 = mustHave "addition is well defined" $ box $ \x -> f1 ⬅ x + f2 ⬅ x

fnSub
  :: Defined dom a
  => Fn dom a AllOf R1
  -> Fn dom a AllOf R1
  -> Fn dom a AllOf R1
fnSub f1 f2 =
  mustHave "subtraction is well defined" $ box $ \x -> f1 ⬅ x - f2 ⬅ x

fnMul
  :: Defined dom a
  => Fn dom a AllOf R1
  -> Fn dom a AllOf R1
  -> Fn dom a AllOf R1
fnMul f1 f2 =
  mustHave "multiplication is well defined" $ box $ \x -> f1 ⬅ x * f2 ⬅ x

-------------- Convergence of a sequence of functions in an Lp-space ------------------

-- Back in Sequences.hs we defined how limits work for sequences of reals.
-- Now define what convergence means for functions in Lp.
-- By Theorem 7.10 (Riesz-Fischer theorem), Lp-space is complete.

-- Because of completeness Cauchy sequences will also have a limit.

-- A sequence of functions in some Lp-space
data LpFnSequence dom a = LpFnSeq {
  measureSpace :: Measure dom a,
  index :: Sequence Subset (Fn dom a AllOf R1),
  p :: ExtR
}

instance (Eq a, Defined dom a) => Defined AllOf (LpFnSequence dom a) where
  candidate _ (LpFnSeq measure index p) =
    valid measure && valid index && p >= fromInteger 1 &&
    -- Functions generated by the sequence should all be measurable
    (forAll (range index) $ \fn -> measurable (algebra measure) lebesgueRd fn) &&
    -- They should stay within the Lp-space
    (forAll (range index) $ \fn -> fn ∈ lpSpace p measure)

lpFnSequence measure index p =
  let candidate = LpFnSeq measure index p
  in  if valid candidate then Just candidate else Nothing

-- This is convergence in mean
-- https://en.wikipedia.org/wiki/Complete_measure
convergesToFn
  :: (Defined dom a, Eq a) => LpFnSequence dom a -> Fn dom a AllOf R1 -> Bool
convergesToFn seq limit | limit ∈ lpSpace (p seq) (measureSpace seq) =
  (lim $ (diff limit) <<. index seq) == Just zero
 where
  diff f1 f2 =
    mustHave "already checked" $ lpNorm (p seq) (measureSpace seq) $ fnSub f1 f2

-- Find the limit of the sequence of functions
limitingFn
  :: (Defined dom a, Eq a) => LpFnSequence dom a -> Maybe (Fn dom a AllOf R1)
limitingFn seq = singleton $ space % \fn -> convergesToFn seq fn
  where space = lpSpace (p seq) (measureSpace seq)

