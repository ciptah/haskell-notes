-- Function spaces and operations on functions.
-- Reference:
-- https://www.math.ucdavis.edu/~hunter/measure_theory/measure_notes_ch7.pdf

{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE Rank2Types #-}

module FunctionSpaces (
  lpNorm,
  lp2Norm,
  lpSpace,
  lp2Space,

  fnAdd,
  fnSub,
  fnMul,

  LpFnSequence,
  lpFnSequence
) where

import GHC.TypeLits
import Data.Proxy

import Sets
import Functions
import Sequences
import Vectors
import SigmaAlgebra
import Measures
import Integral

pow_ :: RealNum -> R1 -> R1
pow_ p x = Vec [(x @@ 0) ** p]

root_ :: RealNum -> Maybe ExtR1 -> Maybe ExtR1
root_ p (Just v) = root__ $ vecToList v
  where root__ [PosInf] = Just $ Vec [PosInf]
        root__ [Finite x] = Just $ Vec [Finite $ x ** (1/p)]
        root__ _ = Nothing
root_ p _ = Nothing

-- The literature mentions "measurable functions" but doesn't define what
-- the sigma-algebra of the codomain is. I'll just take it as the Lebesgue
-- sigma-algebra on R.

-- Lp-space is defined on the measure space of the domain Lp(X, A, µ) 
-- and the exponent-value p. We don't actually need a type.

-- Only for p >= 1. Infinity norm is special that will come later.
lpNorm :: Defined dom a =>
  RealNum -> Measure dom a -> Fn dom a AllOf R1 -> Maybe ExtR1
lpNorm p measure fn = if p >= 1 then root else Nothing
  where all = (outcomes $ algebra $ measure) % \w -> True
        pfn = pow_ p <<. abs <<. fn
        root = root_ p $ integral measure pfn all

lpSpace :: Defined dom a =>
  ExtR -> Measure dom a -> Subset (Fn dom a AllOf R1)
lpSpace (Finite p) measure = everything % \fn ->
  justFinite $ lpNorm p measure fn

lp2Norm :: Defined dom a => Measure dom a -> Fn dom a AllOf R1 -> Maybe ExtR1
lp2Norm = lpNorm 2

lp2Space :: Defined dom a => Measure dom a -> Subset (Fn dom a AllOf R1)
lp2Space = lpSpace (Finite 2)

-------------- Operations of functions as infinite dimensional vectors ------------------

fnAdd :: Defined dom a =>
  Fn dom a AllOf R1 -> Fn dom a AllOf R1 -> Fn dom a AllOf R1
fnAdd f1 f2 = mustHave "addition is well defined" $ box $ \x -> f1 ← x + f2 ← x

fnSub :: Defined dom a =>
  Fn dom a AllOf R1 -> Fn dom a AllOf R1 -> Fn dom a AllOf R1
fnSub f1 f2 = mustHave "subtraction is well defined" $ box $ \x -> f1 ← x - f2 ← x

fnMul :: Defined dom a =>
  Fn dom a AllOf R1 -> Fn dom a AllOf R1 -> Fn dom a AllOf R1
fnMul f1 f2 = mustHave "multiplication is well defined" $ box $ \x -> f1 ← x * f2 ← x

-------------- Convergence of a sequence of functions in an Lp-space ------------------

-- Back in Sequences.hs we defined how limits work for sequences of reals.
-- Now define what convergence means for functions in Lp.
-- By Theorem 7.10 (Riesz-Fischer theorem), Lp-space is complete.

-- Because of completeness Cauchy sequences will also have a limit.

-- A sequence of functions in some Lp-space
data LpFnSequence dom a = LpFnSeq {
  measure :: Measure dom a,
  index :: Sequence Subset (Fn dom a AllOf R1),
  p :: ExtR
}

instance (Eq a, Defined dom a) => Defined AllOf (LpFnSequence dom a) where
  candidate _ (LpFnSeq measure index p) =
    valid measure && valid index && p >= fromInteger 1 &&
    -- Functions generated by the sequence should all be measurable
    (forAll (range index) $ \fn -> measurable (algebra measure) lebesgueRd fn) &&
    -- They should stay within the Lp-space
    (forAll (range index) $ \fn -> fn ∈ lpSpace p measure)

lpFnSequence measure index p = let candidate = LpFnSeq measure index p in
  if valid candidate then Just candidate else Nothing

